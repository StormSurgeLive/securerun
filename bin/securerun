#!/usr/bin/env perl

use strict;
use warnings;

package bin::securerun;

use Getopt::Long qw//;                      # used to process commandline options
use Sys::Hostname;                          # for figuring out hostname
use HTML::Parser;                           # event-based parsing of tags
use File::Copy;                             # used in copying
use File::Path;                             # used in making dirs
use Cwd;                                    # to get current working directory
use YAML;                                   # get $HOME/securerun.conf
use Util::H2O::More qw/h2o opt2h2o/;    # ez inline objects
$|++;                                       # turn off buffering

require Data::Dumper;

# Used to store host information from $SECURERUN->{h} file
use vars qw($AUTOLOAD);

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Constants
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

use constant {
    YES          => 1,
    NO           => 0,
    TRUE         => 1,
    FALSE        => 0,
    EXIT_SUCCESS => 0,
    EXIT_ERROR   => 1,
    EXIT_DIE     => 255,
};

my $VERSION = q{2.0};

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Global Variables
#   Most state variable will be contained inside of the PARSER object,
#   but some not related to the XML processing will be explicitly scoped
#   globally.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

my $HOME = ( getpwuid $< )[7];

# Used by tags to store attributes
my $SCRIPT_ATTS   = {};
my $PUTFILE_ATTS  = {};
my $RUNFILE_ATTS  = {};
my $MYHOSTS       = {};
my $filesToRemove = [];    # Dir creation history array - dir pushed every time mkLocalDir is called

# Global message var
my $SYSMSG = '';

# Used for out of the box operation
my $DEFAULT_localhost = 'localhost';

# tag definition hash is located in ./tags.pl

#
# AUTOLOAD - catch all subroutine - handle or die gracefully
#

sub AUTOLOAD {
    print "WARNING: $AUTOLOAD doesn't exist as a subroutine here.\n";
    return;
}

# Debugging routines

sub ddd (@) {
    print Data::Dumper::Dumper( \@_ );
}

sub dddie (@) {
    print STDERR Data::Dumper::Dumper( \@_ );
    exit 255;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Initialization of options, options processing, and input files
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Initialize extraOps with environmental variables
my $extraOps = {
    PROCID => $$,
    STDOUT => q{},
};

#
# Options defaults
#

my @default_opts = qw/clear tmpdir=s D=s@ i v=i h f=s noenv localhost checkmacro=s saverunfile=s dontprocessrunfile noinputtag nosplash showcomments showtext version/;
my $SECURERUN    = h2o -nolock, {
    D                 => [],
    clear             => undef,
    checkmacro        => 'none',
    saverunfile       => undef,
    nosplash          => undef,
    noinputtag        => undef,
    showcomments      => undef,
    showtext          => undef,
    showversion       => undef,
    dontprocesrunfile => undef,
    i                 => undef,
    create_dirs       => 0,                            #0 means no, 1 means yes
    v                 => 0,                            #0,1,2,4 - where higher is more verbose (noise levels!)
    h                 => qq{$HOME/securerun.conf},     # uses YAML now
    tmpdir            => sprintf( qq{/tmp/%d}, $$ ),
    localhost         => q{localhost},
    f                 => undef,
    noenv             => undef,
  },
  opt2h2o @default_opts;

Getopt::Long::GetOptionsFromArray( \@ARGV, $SECURERUN, @default_opts );

# handle -o FOO=abc...z
foreach my $xo ( @{ $SECURERUN->D } ) {
    my ( $LHS, $RHS ) = split /=/, $xo;
    addToExtraOps( $LHS, $RHS );
}

# Add %ENV into %extraOps
if ( not $SECURERUN->noenv ) {
    %$extraOps = ( %$extraOps, %ENV );
}
else {
    $SYSMSG = "WARNING: ENVIRONMENTAL variables not included in %extraOps (used in macro procession)";
    showIfVerbose( $SYSMSG, 1 );
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create PARSER object
#   Additional elements used to store states during XML processing:
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

my $PARSER = HTML::Parser->new( api_version => 3 );
$PARSER->xml_mode(1);
$PARSER->strict_comment(1);
$PARSER->unbroken_text(1);
$PARSER->{PUTFILE_FLAG}        = 0;
$PARSER->{PUTFILE_SKIP_PFILES} = 0;
$PARSER->{RUNFILE_FLAG}        = 0;
$PARSER->{SCRIPT_FLAG}         = 0;

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Assign callback handlers to events
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

$PARSER->handler( 'start'       => \&onStart,   'tagname,attr' );
$PARSER->handler( 'end'         => \&onEnd,     'tagname' );
$PARSER->handler( 'text'        => \&onText,    'text' );
$PARSER->handler( 'comment'     => \&onComment, 'text' );
$PARSER->handler( 'declaration' => undef );
$PARSER->handler( 'process'     => undef );
$PARSER->handler( 'default'     => undef );

#
# Initialization subroutine
#

sub init {

    #
    # Clear terminal screen option
    #

    if ( $SECURERUN->clear ) {
        system qw/clear/;
    }

    #
    # Prints version
    #

    if ( $SECURERUN->showversion ) {
        print "$VERSION \n\n";
        exit;
    }

    #
    #  Prints text splash by default
    #

    if ( !$SECURERUN->nosplash ) {
        my $parserVersion = HTML::Parser->VERSION;
        print "@@~~~\n@@ securerun: [Parent PROCID: $$]\n@@ $VERSION\n@@ Perl $]\n@@ HTML::Parser $parserVersion\n@@~~~\n\n";
    }

    #
    # Look for ~/securerun.conf if not defined; looks through dirs in PATH
    #

    if ( not -e $SECURERUN->{h} ) {

        # see if environmental variable, SECURERUN_HOST_DEF, is set
        my $tmpfile = '';
        if ( $ENV{SECURERUN_HOST_DEF} ) {
            $tmpfile = $ENV{SECURERUN_HOST_DEF};
        }
        if ( -e $tmpfile ) {
            $SECURERUN->{h} = $tmpfile;
        }
        else {

            # if SECURERUN_HOST_DEF is not set, search path
            for my $path ( split( ":", $ENV{PATH} ) ) {

                # file must exist, be readable by user, and be a text file (as opposed to
                # a binary file)
                if ( -e "$path/$SECURERUN->{h}" ) {
                    $SECURERUN->{h} = "$path/$SECURERUN->{h}";
                    $SYSMSG = "Found $SECURERUN->{h}! ...\n";
                    showIfVerbose( $SYSMSG, 1 );
                    last;
                }
            }
        }
    }

    #
    #  Confirm host definition file exists and read in
    #

    if ( -e $SECURERUN->{h} ) {
        $MYHOSTS = YAML::LoadFile( $SECURERUN->h );
    }
    else {
        print "HALT: $SECURERUN->{h} file not found ...\n";
        exit EXIT_ERROR;
    }

    #
    #  Determine if $SECURERUN->{localhost} is defined;
    #  if it is, return hash record name, if
    #  not, return -1
    #

    setLocalhost();
    addToExtraOps( 'localhost', $SECURERUN->{localhost} );

    open( TTY, "</dev/tty" ) or die $!;

    showCallerInfo(caller);
    return;
}    # end sub init

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# System helper functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub isLocalDir {
    my ($dir) = @_;
    my $retval = 0;
    if ( -d $dir ) {
        $retval = 1;
    }
    showCallerInfo(caller);
    return $retval;
}

sub isLocalFile {
    my ($file) = @_;
    my $retval = 0;
    if ( -e $file && -f $file ) {
        $retval = 1;
    }
    showCallerInfo(caller);
    return $retval;
}

sub ensureLocalDir {
    my ( $dir, $mode ) = @_;
    my $retval = 0;
    if ( $SECURERUN->{create_dirs} eq 1 ) {

        # mkdir if $dir doesn't exist or if $dir is not a directory
        if ( not -e $dir ) {
            $retval = mkpath( $dir, 0, $mode ) or die $!;
        }
        else {
            my $pwd = getcwd;
            $SYSMSG = "WARNING: $dir already exists; Directory not removed \nCommand issued while in $pwd...\n";
            showIfVerbose( $SYSMSG, 2 );
        }
    }
    else {
        warn "WARNING: Could not create $dir because \"-create_dirs\" not set to 1...\n";
    }
    showCallerInfo(caller);
    return $retval;
}

sub touchFile {
    my ($file) = @_;
    open my $fh, '>', "$file" or die $!;
    print $fh '';
    close $fh;
    showCallerInfo(caller);
    return;
}

# set up for UNIX paths
sub getParentPath {
    my $path          = $_[0];
    my @filePathArray = split( "/", $path );

    # discard last member
    pop(@filePathArray);
    showCallerInfo(caller);
    return join( "/", @filePathArray );
}

# set up for UNIX paths
sub getLastPathMember {
    my $path          = $_[0];
    my @filePathArray = split( "/", $path );
    showCallerInfo(caller);
    return pop(@filePathArray);
}

# cd to BASEDIR
sub cdCwdToBASEDIR {
    chdir $SECURERUN->{BASEDIR} or die $!;
    showCallerInfo(caller);
    return;
}

sub cdCwdToDir {
    my ($dir) = $_[0];
    chdir $dir or die $!;
    showCallerInfo(caller);
    return;
}

# checks to see if file is a directory or if it exists
sub prepForNewFile {
    my ($filepath) = $_[0];
    if ( -d $filepath ) {
        print "HALT: $filepath exists and IS a directory, not a file!...\n";
        exit;
    }
    elsif ( -e $filepath ) {
        unlink $filepath;
    }
    showCallerInfo(caller);
    return;
}

sub getTmpName {
    srand time;
    return sprintf( qq{%d%s}, $$, int rand 100_000 );
}

#
# getFirstLineFromFile
# ...removes shebang line and returns it as the INTERP
# to use when running - has potential to be misused!
#

sub getFirstLineFromFile {
    my ($file) = @_;
    my $line;
    my $filecontent;
    open my $fh, '<', "$file";

    # get interp path from shebang it is there
    while (<$fh>) {
        $line = $_;
        last;
    }
    close $fh;
    showCallerInfo(caller);
    return $line;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Runtime preference processing functions
#  For each valid runtime preference setting, there must be a corresponding
#  subrouting to handle it.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub pref_create_dirs {
    my ($level) = @_;
    if ( $level =~ m/[01]/ ) {
        $SECURERUN->{create_dirs} = $level;
    }
    $SYSMSG = "SET: create_dirs to $level\n";
    showIfVerbose( $SYSMSG, 4 );
    showCallerInfo(caller);
    return;
}

sub pref_verbose_level {
    my ($level) = @_;
    if ( $level =~ m/[\d]+/ ) {
        $SECURERUN->{v} = $level;
    }
    $SYSMSG = "SET: on_verbose_level to $level\n";
    showIfVerbose( $SYSMSG, 4 );
    showCallerInfo(caller);
    return;
}

sub processPrefs {
    my $prefs = $SECURERUN->{PREFS};
    $prefs =~ s/\n|\s|\r//g;
    ## register any new internal XML prefs here
    my $set_pref = {
      q{-create_dirs}   => sub { pref_create_dirs(@_)   },
      q{-verbose_level} => sub { pref_verbose_level(@_) },
    };
    my @prefsArray = split( ';', $prefs );
    foreach my $pref (@prefsArray) {
        my ($pref, $value) = split /:/, $pref;
	if (q{CODE} eq ref $set_pref->{$pref}) {
	  $set_pref->{$pref}->($value)
	}
	else {
          $SYSMSG = sprintf qq{WARNING: '%s' is not a valid preference in opening <securerun prefs="...\nValid: %s\n}, $pref, join(q{, }, keys %$set_pref);
          showIfVerbose( $SYSMSG, 0 );
	}
    }
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging and messaging functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#
# showIfVerbose($message,$verboseFlag)
# Displays $message if $verboseFlag is true
#

sub showIfVerbose {
    my ( $msg, $level ) = @_;
    if ( $SECURERUN->{v} >= $level ) {

        # parameter assignment
        if ($msg) {
            chomp $msg;
            print "$msg\n";
        }
    }

    # DO NOT PUT showCallerInfo() here!
    $SYSMSG = '';
    showCallerInfo(caller);
    return;
}

#
#  Output function caller info for debugging at
#  the highest verbose level
#  This function must be called like:
#  &showCallerInfo;
#

sub showCallerInfo {
    my (@callerInfo) = @_;
    my $callerInfo = \@callerInfo;
    if ( $SECURERUN->{v} >= 4 ) {
        my $pwd = getcwd;
        print "+-----DEBUG-----+\n";
        print "Called from $callerInfo[1] on line $callerInfo[2]\n";
        print "Current working directory is $pwd\n";
    }

    # DO NOT PUT showCallerInfo() here!
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Macro parsing
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# heart of macro processing for strings
sub preProcessStr {
    my ( $string, $options ) = @_;
    $SYSMSG = "Processing macros (preProcessStr)...\n";
    showIfVerbose( $SYSMSG, 2 );
    $string =~ s/%([_a-zA-Z0-9\.-]+?)%/exists($options->{$1}) ? $options->{$1} : "%$1%"/ge;
    checkForMacros($string);
    showCallerInfo(caller);
    return $string;
}

sub preProcessFile {
    my ( $file, $options ) = @_;

    # ensure file is a text file, ie, not binary
    if ( -T $file ) {
        $SYSMSG = "Processing macros in $file...\n";
        showIfVerbose( $SYSMSG, 2 );

        # Build string containing file txt (include control chars)
        my $FILETXT = '';
        open my $fh, '<', "$file" or die "Cannot open $file for reading: $!";
        while (<$fh>) {
            $FILETXT .= $_;
        }
        close $fh;

        # Replace macros in string with %options hash
        $FILETXT = preProcessStr( $FILETXT, $options );

        # Replace file!!
        prepForNewFile($file);
        open $fh, '>', "$file" or die "Cannot open $file for writing: $!";
        print $fh $FILETXT;
        close $fh;
    }
    else {
        $SYSMSG = "WARNING: $file is not a text file, so macros can not be processed...\n";
        showIfVerbose( $SYSMSG, 1 );
    }
    showCallerInfo(caller);
    return;
}

# pre processes file, then outputs to a tmp file.  Returns new file path

sub getTmpPreProcessedFile {
    my ( $file, $options ) = @_;
    my $tmpSrcFile = '';
    if ( -r $file ) {

        # suck file content into string and process macros
        my $filecontent = txtFileToString($file);

        # Process macros in tmp local file
        $filecontent = preProcessStr( $filecontent, $options );

        # dump file contents to tmp file
        my $tmpname = getTmpName();
        $tmpSrcFile = sprintf qq{%s/%s}, $SECURERUN->{tmpdir}, $tmpname;

        # send file to remote host
        open my $DUMP, '>', "$tmpSrcFile" || die $!;
        print $DUMP $filecontent;
        close $DUMP;
    }
    return $tmpSrcFile;
}

sub checkForMacros {
    my ($txtToCheck) = $_[0];
    ## Check for left over macros
    if ( $SECURERUN->checkmacro eq "warn" or $SECURERUN->checkmacro eq "halt" ) {
        if ( $txtToCheck =~ m/(%[a-zA-Z0-9]*%)/ ) {
            if ( $SECURERUN->{checkmacro} eq "warn" ) {
                warn "WARNING: Undefined macro detected: $1...\n";
            }
            elsif ( $SECURERUN->checkmacro eq "halt" ) {
                print "HALT: Undefined macro detected: $1...\n";
                exit;
            }
        }
    }
    showCallerInfo(caller);
    return;
}

sub addToExtraOps {
    my ( $varName, $value ) = @_;

    # also replaces hash element if assigned already
    $extraOps->{$varName} = $value;
    showCallerInfo(caller);
    return;
}

sub removeFromExtraOps {
    my ($varName) = @_;
    if ( $extraOps->{$varName} ) {

        # remove from hash
        delete $extraOps->{$varName};
    }
    showCallerInfo(caller);
    return;
}

sub txtFileToString {
    my ($file) = $_[0];
    my $retstr = '';
    if ( -e $file && -T $file ) {
        open my $TMPFILE, '<', "$file";
        while (<$TMPFILE>) {
            $retstr .= $_;
        }
        close $TMPFILE;
    }
    else {
        warn "WARNING: $file either doesn't exist or is not a text file..\n";
    }
    return $retstr;
}

sub dumpFileContent {
    my ( $content, $file ) = @_;
    open my $TMPFILE, '>', "$file" || die $!;
    print $TMPFILE $content;
    close $TMPFILE;
    return;
}

# parse "cmd" used in <runfile> and <define>

sub createCmd {
    my ( $interp, $file ) = @_;

    # %i = interp
    # %a = args
    # %f = file
    chomp( $interp, $file );
    my $srcFileHash = parseDirPath( $RUNFILE_ATTS->{file} );
    my $cmd         = $RUNFILE_ATTS->{cmd};
    $cmd =~ s/%a/$RUNFILE_ATTS->{args}/g;
    $cmd =~ s/%f/$file/g;
    $cmd =~ s/%i/$interp/g;
    $SYSMSG = "Created command:'$cmd'\n";
    showIfVerbose( $SYSMSG, 2 );
    return $cmd;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Validation functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# experimental generic attribute validation scheme
sub validateAttributes {
    my ( %AttDef, @attributes ) = @_;

    # to be implemented soon

    showCallerInfo(caller);
    return;
}

sub validatePipe {
    my ( $pipe, $default ) = @_;
    if ($pipe) {
        chomp $pipe;
        if ( $pipe !~ m/[|]?|[<]{0,2}|[>]{0,2}/ ) {
            warn "WARNING: illegal pipe symbol detected ... reset to null string ...\n";
            $pipe = '';
        }
    }
    else {
        $pipe = $default;
    }
    showCallerInfo(caller);
    return $pipe;
}

sub validateWait {
    my ($wait) = @_;
    if ($wait) {
        chomp $wait;
        if ( $wait !~ m/^[0-9]*$/ ) {
            $wait = 0;
        }
    }
    else {
        $wait = 0;
    }
    showCallerInfo(caller);
    return $wait;
}

sub validateYesNo {
    my ( $yesNo, $default ) = @_;
    if ($yesNo) {
        chomp( $yesNo, $default );
        if ( $yesNo =~ m/^[nN][oO]$/ or $yesNo =~ m/^[nN]$/ or $yesNo eq 0 ) {
            $yesNo = "NO";
        }
        elsif ( $yesNo =~ m/^[yY][eE][sS]$/ or $yesNo =~ m/^[yY]$/ or $yesNo eq 1 ) {
            $yesNo = "YES";
        }
        else {
            $yesNo = $default;
        }
    }
    else {
        $yesNo = $default;
    }
    showCallerInfo(caller);
    return $yesNo;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# host info functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#
#  gets interpretor information from $MYHOSTS
#

sub getInterpInfo {
    my ( $host, $interp ) = @_;
    chomp( $host, $interp );
    my $hostrecord = getHostRecordName($host);
    my $rethash    = {};
    $rethash->{VALID} = 0;
    if ( $hostrecord ne -1 ) {

        # get interp
        for my $interplist ( @{ $MYHOSTS->{$hostrecord}->{INTERP} } ) {
            if ( $interp eq $interplist->{alias} ) {
                $rethash->{BIN}         = $interplist->{bin};
                $rethash->{FLAGS}       = $interplist->{flags};
                $rethash->{DEFAULT_CMD} = $interplist->{default_cmd};
                $rethash->{VALID}       = 1;

                # break out of for loop
                last;
            }
        }
    }
    showCallerInfo(caller);
    return h2o $rethash;
}

# ensure interp if listed in securerun.ini for host in $rundir
sub isValidInterp {
    my ( $interp, $rundir ) = @_;
    chomp( $interp, $rundir );
    my $isLocal = isLocal($rundir);
    my $host    = '';
    my $retval  = 0;
    if ( $isLocal eq 1 ) {
        $host = $SECURERUN->{localhost};
    }
    elsif ( $isLocal eq 0 ) {
        my $hostHash = parseDirPath($rundir);
        $host = $hostHash->{HOST};
    }
    else {
        $retval = -1;
    }
    if ( $retval ne -1 ) {
        my $interpHash = getInterpInfo( $host, $interp );
        $retval = $interpHash->{VALID};
    }
    showCallerInfo(caller);
    return $retval;
}

#
# returns hash of dir path elements including
# username, host, and ssh/scp port to use
#

sub parseDirPath {
    my ($path)  = @_;
    my %rethash = ();
    my $rethash = \%rethash;
    $rethash->{VALID} = 0;

    # This crazy regex parses out path info, including remote host stuff
    # using the format user@host#port:/path - the only thing required is "/path"
    if ( $path =~ m/(((^[%\D0-9]*)(@))?([%_a-zA-Z0-9\.-]*)((#)([%\D0-9]*))?(:))?([%\D0-9]*)/i ) {
        $rethash->{USERNAME} = $3;
        $rethash->{HOST}     = $5;
        $rethash->{PORT}     = $8;
        $rethash->{PATH}     = $10;
        $rethash->{VALID}    = 1;
    }
    if ( not $rethash->{USERNAME} ) {

        # If not defined, ensure null string
        $rethash->{USERNAME} = '';
    }
    if ( not $rethash->{PORT} ) {

        # If not defined, use default secure shell port
        $rethash->{PORT} = 22;
    }
    if ( not $rethash->{PATH} ) {

        # If not defined, default to remote home dir
        $rethash->{PATH} = '~';
    }
    showCallerInfo(caller);
    return \%rethash;
}

#
#  Fundemental host file query
#  returns HRN given an IP addr or alias
#

sub getHostRecordName {
    my ($aliasOrIP) = $_[0];
    my $hostname = -1;
    foreach my $hostrecord ( keys %$MYHOSTS ) {
        foreach my $namelist ( @{ $MYHOSTS->{$hostrecord}->{HOSTINFO} } ) {
            if ( $aliasOrIP eq $namelist->{name} or $aliasOrIP eq $namelist->{ipaddress} ) {
                $hostname = $hostrecord;

                # break out of for loop
                last;
            }
        }
        if ( $hostname ne -1 ) {

            # break out of foreach loop and return $found
            last;
        }
    }
    showCallerInfo(caller);
    return $hostname;
}

#
#  Fundemental host file query
#  returns IP addr given an IP addr or alias
#

sub getIPAddress {
    my ($aliasOrIP) = $_[0];
    my $ipaddress = -1;
    foreach my $hostrecord ( keys %$MYHOSTS ) {
        for my $namelist ( @{ $MYHOSTS->{$hostrecord}->{HOSTINFO} } ) {
            if ( $aliasOrIP eq $namelist->{name} or $aliasOrIP eq $namelist->{ipaddress} ) {
                $ipaddress = $namelist->{ipaddress};

                # break out of for loop
                last;
            }
        }
        if ( $ipaddress ne -1 ) {

            # break out of foreach loop and return $found
            last;
        }
    }
    showCallerInfo(caller);
    return $ipaddress;
}

#
#  Determines if host is in def file giben IP addr, alias, or HRN
#

sub isInHostFile {
    my ($aliasOrIP) = $_[0];
    my $retval = 0;
    if ( defined( $MYHOSTS->{$aliasOrIP} ) ) {
        $retval = 1;
    }
    elsif ( getIPAddress($aliasOrIP) ne -1 ) {
        $retval = 1;
    }
    elsif ( getHostRecordName($aliasOrIP) ne -1 ) {
        $retval = 1;
    }
    showCallerInfo(caller);
    return $retval;
}

#
# attempts to figure out if $path is on localhost
#

sub isLocal {
    my ($path) = $_[0];
    my $retval = 0;
    if ( defined($path) ) {
        my $hostHash = parseDirPath($path);
        if ( defined( $hostHash->{HOST} ) ) {
            if ( isInHostFile( $hostHash->{HOST} ) ) {
                my $ip1 = getIPAddress( $SECURERUN->{localhost} );
                my $ip2 = getIPAddress( $hostHash->{HOST} );
                if ( $ip1 eq $ip2 ) {
                    $retval = 1;
                }
            }
            else {

                # indicates host that is not in host file
                $retval = -1;
            }
        }
        else {

            # Assuming that if $hostHash->{HOST} doesn't exist, it is localhost syntax
            $retval = 1;
        }
    }
    showCallerInfo(caller);
    return $retval;
}

#
# Actually runs isLocal and inverses result unless "-1" indicating that it is not in securerrun.def
#

sub isRemote {
    my ($path)     = @_;
    my $retval     = 0;
    my $isLocalVal = isLocal($path);
    if ( $isLocalVal eq 1 ) {
        $retval = 0;
    }
    elsif ( $isLocalVal eq 0 ) {
        $retval = 1;
    }
    else {
        $retval = $isLocalVal;
    }
    return $retval;
}

#
#  Set localhost for run
#

sub setLocalhost {
    my ( $fullnetname, $alias );
    if ( $SECURERUN->{localhost} =~ m/^$/ ) {
        ( $fullnetname, $alias ) = gethostbyname( hostname() );
    }
    else {
        $fullnetname = $SECURERUN->{localhost};
        $alias       = $SECURERUN->{localhost};
    }

    # first try fullnetname
    my $tmpgetip = getIPAddress($fullnetname);
    if ( $tmpgetip eq -1 ) {

        # if that fails, try alias
        $tmpgetip = getIPAddress($alias);
        if ( $tmpgetip eq -1 ) {

            # if that fails, try $DEFAULT_localhost
            $tmpgetip = getIPAddress($DEFAULT_localhost);
            if ( $tmpgetip eq -1 ) {
                print "HALT: Specified localhost, \"$fullnetname\", not in $SECURERUN->{h} ...\n";
                exit;
            }
        }
    }

    # if it works, assign ip address to localhost
    $SECURERUN->{localhost} = $tmpgetip;

    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# SSH/SCP wrappers and run file helper functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub execViaSSH {
    my ( $host, $user, $port, $cmd ) = @_;
    my $retval  = '';
    my $sshHash = getInterpInfo( $SECURERUN->localhost, "SSH" );

    # Create $hoststr, ie, user@host...
    my $hoststr = $host;
    if ($user) {
        $hoststr = "$user\@$host";
    }

    if ( $sshHash->VALID and -x $sshHash->BIN ) {
        $SYSMSG = "Attempting to execute remote command(s) using connect string \"$hoststr\":\n  $cmd\n";
        showIfVerbose( $SYSMSG, 1 );
        my $exec = sprintf qq{%s -p %s %s %s '%s 2>&1'}, $sshHash->BIN, $port, $sshHash->FLAGS, $hoststr, $cmd;
        $retval = qx/$exec/;
        my $exit_code = $? >> 8;
        if ( $exit_code != EXIT_SUCCESS ) {
            printf "HALT: ssh command exited non-zero code ($exit_code)\n$retval";
            exit $exit_code;
        }
    }
    else {
        printf qq{HALT: ssh not valid or not executable on %s\n}, $SECURERUN->{localhost};
        exit EXIT_ERROR;
    }
    showCallerInfo(caller);
    return $retval;
}

# getViaSCP($scpExe,$hostFilePath,$localPath)
#   gets a remote file via scp
#

sub getViaSCP {
    my ( $host, $user, $port, $rmtFile, $localPath ) = @_;
    my ( $retval, $usrstr );
    my $scpHash = getInterpInfo( $SECURERUN->{localhost}, "SCP" );

    # Create $hoststr, ie, user@host...
    my $hoststr = $host;
    if ($user) {
        $hoststr = "$user\@$host";
    }

    if ( $scpHash->{VALID} and -x $scpHash->{BIN} ) {
        $SYSMSG = "Attemping to get file(s) using connect string \"$hoststr\":\n $rmtFile \n";
        showIfVerbose( $SYSMSG, 1 );
        my $exec = sprintf qq{%s -P %s %s %s:%s %s 2>&1}, $scpHash->BIN, $port, $scpHash->FLAGS, $hoststr, $rmtFile, $localPath;
        $retval = qx/$exec/;
        my $exit_code = $? >> 8;
        if ( $exit_code != EXIT_SUCCESS ) {
            printf "HALT: ssh command exited non-zero code ($exit_code)\n$retval";
            exit $exit_code;
        }
    }
    else {
        printf qq{HALT: scp not valid or not executable on %s\n}, $SECURERUN->{localhost};
        exit EXIT_ERROR;
    }
    showCallerInfo(caller);
    return $retval;
}

#
# putViaSCP($host,$user,$port,$localFile,$rmtPath)
#   puts a local file on a remote machine via scp
#

sub putViaSCP {
    my ( $host, $user, $port, $localFile, $rmtPath ) = @_;
    my ( $retval, $usrstr );
    my $scpHash = getInterpInfo( $SECURERUN->{localhost}, "SCP" );

    # Create $hoststr, ie, user@host...
    my $hoststr = $host;
    if ($user) {
        $hoststr = "$user\@$host";
    }

    if ( $scpHash->{VALID} eq 1 and -x $scpHash->{BIN} ) {
        $SYSMSG = "Attemping to put local file(s) to remote path $rmtPath using connect string \"$hoststr\":\n $localFile \n";
        showIfVerbose( $SYSMSG, 1 );
        my $exec = sprintf qq{%s -P %s %s %s %s:%s 2>&1}, $scpHash->BIN, $port, $scpHash->FLAGS, $localFile, $hoststr, $rmtPath;
        $retval = qx/$exec/;
        my $exit_code = $? >> 8;
        if ( $exit_code != EXIT_SUCCESS ) {
            printf "HALT: ssh command exited non-zero code ($exit_code)\n$retval";
            exit $exit_code;
        }
    }
    else {
        print "HALT: scp not valid on $SECURERUN->{localhost}\n";
        exit;
    }
    showCallerInfo(caller);
    return $retval;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  <securerun> state support functions -- ROOT tag!
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub securerunTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;

    # Record directory securerun was executed from
    $SECURERUN->{INITIALDIR} = getcwd;
    chomp $SECURERUN->{INITIALDIR};
    if ( exists( $attributes->[0]{prefs} ) ) {
        $SECURERUN->{PREFS} = $attributes->[0]{prefs};
        processPrefs();
    }
    else {
        $SECURERUN->{PREFS} = '';
    }
    if ( exists( $attributes->[0]{name} ) ) {
        $SECURERUN->{NAME} = $attributes->[0]{name};
    }
    else {
        $SECURERUN->{NAME} = "securerun.$$";
    }

    # basedir
    if ( exists( $attributes->[0]{basedir} ) ) {
        ensureLocalDir( qq($attributes->[0]{basedir}), 0755 );
        $SECURERUN->{BASEDIR} = Cwd::realpath(qq($attributes->[0]{basedir}));
        chomp $SECURERUN->{BASEDIR};
    }
    else {

        # Assume basedir is current one, and assign via absolute path
        $SECURERUN->{BASEDIR} = getcwd;
        chomp $SECURERUN->{BASEDIR};
    }

    # Add STARTDIR to default - i.e. the cwd where securerun is executed (not necessarily the BASEDIR!)
    addToExtraOps( 'STARTDIR', getcwd() );

    # Add basedir to %extraOps
    addToExtraOps( 'BASEDIR', $SECURERUN->{BASEDIR} );

    # tmpdir
    if ( exists( $attributes->[0]{tmpdir} ) ) {
        ensureLocalDir( qq($attributes->[0]{tmpdir}), 0755 );
        $SECURERUN->{tmpdir} = Cwd::realpath(qq($attributes->[0]{tmpdir}));
        chomp $SECURERUN->{tmpdir};
    }    # default is set at the top, Add tmpdir to %extraOps
    addToExtraOps( 'tmpdir', $SECURERUN->{tmpdir} );

    # logfile
    $SECURERUN->{LOGFILE} = "$SECURERUN->{BASEDIR}/securerun.$$.log";

    # Add logdir to %extraOps
    addToExtraOps( 'LOGFILE', $SECURERUN->{LOGFILE} );

    # Change to $SECURERUN->{BASEDIR} to start the show
    cdCwdToBASEDIR();
    showCallerInfo(caller);
    return;
}

sub securerunTagEnd {
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# <putfile>/<pfile> state support functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub putfileTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;

    # Block "put" attribute - if NO, set $PARSER->{PUTFILE_FLAG} = 0 so entire block is ignored
    if ( validateYesNo( $attributes->[0]{put}, 'YES' ) eq 'YES' ) {
        $PARSER->{PUTFILE_FLAG}        = 1;
        $PARSER->{PUTFILE_SKIP_PFILES} = 0;
        if ( defined( $attributes->[0]{to} ) ) {
            $PUTFILE_ATTS->{to} = qq($attributes->[0]{to});
            my $isLocal = isLocal( $PUTFILE_ATTS->{to} );
            if ( $isLocal eq 1 ) {
                $PUTFILE_ATTS->{localOrRemote} = 'local';                                         # Store that it is local for entire <putfile> block
                $SYSMSG = "$PUTFILE_ATTS->{to} is local and valid...\n";
                showIfVerbose( $SYSMSG, 2 );
            }
            elsif ( $isLocal eq 0 ) {
                $PUTFILE_ATTS->{localOrRemote} = 'remote';                                         # Store that it is local for entire <putfile> block
                $SYSMSG = "$PUTFILE_ATTS->{to} is remote and valid...\n";
                showIfVerbose( $SYSMSG, 2 );
            }
            elsif ( $isLocal eq -1 ) {
                print "HALT: $PUTFILE_ATTS->{to} is not a valid file destination...\n";
                exit EXIT_ERROR;
            }
        }
        else {
            print "HALT: <putfile> destination directory not defined!...\n";
            exit EXIT_ERROR;
        }

        # Wait attribute
        sleep validateWait( $attributes->[0]{wait} );
    }
    else {

        # set $PARSER->{PUTFILE_FLAG} = 0 so <pfile> stuff is ignored...
        $PARSER->{PUTFILE_FLAG}        = 0;
        $PARSER->{PUTFILE_SKIP_PFILES} = 1;
        $SYSMSG                        = "WARNING: Ignoring <putfile> block because <putfile put=\"NO\"> was detected...\n";
        showIfVerbose( $SYSMSG, 2 );
    }
    showCallerInfo(caller);
    return;
}

sub putfileTagEnd {

    # Reset flags and global putfile tag attribute hash
    $PARSER->{PUTFILE_FLAG}        = 0;
    $PARSER->{PUTFILE_SKIP_PFILES} = 0;

    # reset global attributes hash
    $PUTFILE_ATTS = {};
    showCallerInfo(caller);
    return;
}

sub pfileTagStart {
    my (@attributes) = $_[0];
    my $attributes   = \@attributes;
    my $skip         = 0;
    my $standalone   = 0;
    if ( $PARSER->{PUTFILE_SKIP_PFILES} eq 0 ) {
        if ( $PARSER->{PUTFILE_FLAG} ne 1 ) {

            # validates dir attribute
            putfileTagStart(@attributes);
            $standalone = 1;
        }
        else {

            # honor wait attribute
            sleep validateWait( $attributes->[0]{wait} );
        }

        #put
        $PUTFILE_ATTS->{put} = validateYesNo( $attributes->[0]{put}, "YES" );
        if ( $PUTFILE_ATTS->{put} eq 'YES' ) {

            # Only deal with if putting this file
            #require
            $PUTFILE_ATTS->{require} = validateYesNo( $attributes->[0]{require}, "YES" );
            if ( $attributes->[0]{src} ) {
                $PUTFILE_ATTS->{src} = $attributes->[0]{src};
            }
            else {
                if ( $PUTFILE_ATTS->{require} eq 'YES' ) {
                    print qq{HALT: 'src=""' attribute missing in required <pfile /> entry ...\n};
                    exit EXIT_ERROR;
                }
                else {
                    warn qq{WARNING: 'file=""' attribute missing in required <pfile /> entry,  skipped\n};
                    $skip = 1;
                }
            }
            if ( $skip eq 0 ) {

                # Only deal with if $skip is set to 0
                # as
                if ( $attributes->[0]{as} ) {

                    # Should be file name only - not a dir path!
                    $PUTFILE_ATTS->{as} = qq($attributes->[0]{as});

                    # Validate as if contained
                    if ( $PUTFILE_ATTS->{as} ne '' ) {
                        if ( $PUTFILE_ATTS->{as} =~ m/\// ) {
                            warn "WARNING $PUTFILE_ATTS->{as} appears to be a directory path and not a filename - $PUTFILE_ATTS->{src} will not be renamed...\n";
                            $PUTFILE_ATTS->{as} = '';
                        }
                    }
                }
                else {
                    $PUTFILE_ATTS->{as} = '';
                }

                # process? defaults to no
                $PUTFILE_ATTS->{process} = validateYesNo( $attributes->[0]{process}, "NO" );

                # keep original?  defaults to yes
                $PUTFILE_ATTS->{keep} = validateYesNo( $attributes->[0]{keep}, "YES" );

                # Put file
                putFileManager();

                # Clean up if standalone tag
                if ( $standalone eq 1 ) {
                    putfileTagEnd();
                }
            }
        }
    }
    showCallerInfo(caller);
    return;
}

# Called immediately after pfileTagStart, but does nothing right now
sub pfileTagEnd {
    if ( $PARSER->{PUTFILE_SKIP_PFILES} eq 0 ) {

        # Reset $PUTFILE_ATTS
        $PUTFILE_ATTS->{put}     = '';
        $PUTFILE_ATTS->{src}     = '';
        $PUTFILE_ATTS->{require} = '';
        $PUTFILE_ATTS->{process} = '';
        $PUTFILE_ATTS->{as}      = '';
        $PUTFILE_ATTS->{keep}    = '';
        $PUTFILE_ATTS->{wait}    = '';
    }
    showCallerInfo(caller);
    return;
}

# Chooses which putfile case to handle

sub putFileManager {

    # Validate source file
    if ( isLocal( $PUTFILE_ATTS->{src} ) && $PUTFILE_ATTS->{localOrRemote} eq 'local' ) {
        putLocalToLocal();    # Move local file to another local dir
    }
    elsif ( isLocal( $PUTFILE_ATTS->{src} ) && $PUTFILE_ATTS->{localOrRemote} eq 'remote' ) {
        putLocalToRemote();    # Move local file to remote dir
    }
    elsif ( isRemote( $PUTFILE_ATTS->{src} ) && $PUTFILE_ATTS->{localOrRemote} eq 'local' ) {
        putRemoteToLocal();    # Move a file from a remote host to local dir
    }
    elsif ( isRemote( $PUTFILE_ATTS->{src} ) && $PUTFILE_ATTS->{localOrRemote} eq 'remote' ) {

        # Move file on remote host 1 to dir on remote host 2
        # Currently inefficient - localhost used as "man in the middle"
        #  remote1-->local-->remote2
        putRemote1ToRemote2();
    }
    else {
        print "HALT: Can not be determined if $PUTFILE_ATTS->{src} is local or remote...\n";
        exit;
    }
    showCallerInfo(caller);
    return;
}

# copies src file to local dir - macro processing done after the move

sub putLocalToLocal {
    my $destHash    = parseDirPath( $PUTFILE_ATTS->{to} );
    my $srcFileHash = parseDirPath( $PUTFILE_ATTS->{src} );

    # make sure src file exists
    if ( not isLocalFile( $srcFileHash->{PATH} ) ) {
        if ( $PUTFILE_ATTS->{require} eq 'YES' ) {
            print "HALT: file \"$srcFileHash->{PATH}\" can not be found ...\n";
            exit EXIT_ERROR;
        }
        else {
            warn "WARNING: \"$srcFileHash->{PATH}\" can not be found ...\n";
        }
    }
    else {
        # make sure destination directory is there
        ensureLocalDir( $destHash->{PATH}, 0755 );
        $destHash->{PATH} = Cwd::realpath( $destHash->{PATH} );

        # copy src file to local destination dir - check for new name
        my $newfiledestination = '';
        if ( $PUTFILE_ATTS->{as} ne '' ) {
            $newfiledestination = "$destHash->{PATH}/$PUTFILE_ATTS->{as}";
        }
        else {
            my $filename = getLastPathMember( $srcFileHash->{PATH} );
            $newfiledestination = "$destHash->{PATH}/$filename";
        }
        prepForNewFile($newfiledestination);
        copy( $srcFileHash->{PATH}, $newfiledestination ) or die "HALT: Error copying file...\n";

        # Process macros in local file
        if ( $PUTFILE_ATTS->{process} eq 'YES' ) {
            preProcessFile( $newfiledestination, $extraOps );
        }

        # Schedule file for removal if keep=YES
        if ( $PUTFILE_ATTS->{keep} eq 'NO' ) {
            push @$filesToRemove, $srcFileHash->{PATH};
        }
    }
    return;
}

sub putLocalToRemote {
    my $destHash           = parseDirPath( $PUTFILE_ATTS->{to} );
    my $srcFileHash        = parseDirPath( $PUTFILE_ATTS->{src} );
    my $tmpfiledestination = '';

    # make sure src file exists
    if ( isLocalFile( $srcFileHash->{PATH} ) eq 0 ) {
        if ( $PUTFILE_ATTS->{require} eq 'YES' ) {
            print "HALT: $srcFileHash->{PATH} can not be located...\n";
            exit;
        }
        else {
            warn "WARNING: $srcFileHash->{PATH} can not be located...\n";
        }
    }
    else {

        # Send file to remote host
        my $hostIPAddress = getIPAddress( $destHash->{HOST} );

        # get host ip, verify
        if ( $hostIPAddress ne -1 ) {

            # suck file content into string and process macros
            my $tmpSrcFile = '';
            if ( $PUTFILE_ATTS->{process} eq 'YES' ) {

                # Process macros in tmp local file, get path to file to use
                $tmpSrcFile = getTmpPreProcessedFile( $srcFileHash->{PATH}, $extraOps );

                # schedule tmp file for deletion
                push @$filesToRemove, $tmpSrcFile;
            }
            else {
                $tmpSrcFile = $srcFileHash->{PATH};
            }
            my $destination = '';
            if ( $PUTFILE_ATTS->{as} ne '' ) {

                # send under guise of "as"
                $destination = "$destHash->{PATH}/$PUTFILE_ATTS->{as}";
            }
            else {

                # send as original file
                my $filename = getLastPathMember( $srcFileHash->{PATH} );
                $destination = "$destHash->{PATH}/$filename";
            }
            my $scpout = putViaSCP(
                $hostIPAddress,
                $destHash->{USERNAME},
                +$destHash->{PORT},
                $tmpSrcFile, $destination
            );

            # stdout
            showIfVerbose( $scpout, 1 );

            # Schedule original file for removal if keep=YES
            if ( $PUTFILE_ATTS->{keep} eq 'NO' ) {
                push @$filesToRemove, $srcFileHash->{PATH};
            }
        }
        else {
            print "HALT: $destHash->{HOST} has no associated IP address in $SECURERUN->{h}\n";
            exit;
        }
    }
    return;
}

# copies a remote file to a local dir - macro processing done once it is on the local host

sub putRemoteToLocal {
    my $destHash    = parseDirPath( $PUTFILE_ATTS->{to} );
    my $srcFileHash = parseDirPath( $PUTFILE_ATTS->{src} );

    # make sure destination directory is there
    ensureLocalDir( $destHash->{PATH}, 0755 );

    # get absolute path
    $destHash->{PATH} = Cwd::realpath( $destHash->{PATH} );

    # Get file from remote
    my $hostIPAddress = getIPAddress( $srcFileHash->{HOST} );
    if ( $hostIPAddress ne -1 ) {
        my $newfiledestination = '';
        if ( $PUTFILE_ATTS->{as} ne '' ) {
            $newfiledestination = "$destHash->{PATH}/$PUTFILE_ATTS->{as}";
        }
        else {
            my $filename = getLastPathMember( $srcFileHash->{PATH} );
            $newfiledestination = "$destHash->{PATH}/$filename";
        }
        prepForNewFile($newfiledestination);

        # get file from remote host
        my $scpout = getViaSCP(
            $hostIPAddress,       $srcFileHash->{USERNAME}, $srcFileHash->{PORT},
            $srcFileHash->{PATH}, $newfiledestination
        );
        showIfVerbose( $scpout, 1 );

        # Ensure file was copied over
        if ( !-e $newfiledestination ) {
            if ( $PUTFILE_ATTS->{require} eq 'YES' ) {
                print "HALT: Problem getting $newfiledestination from $srcFileHash->{PATH}...\n";
                exit;
            }
            else {
                warn "WARNING: Problem getting $newfiledestination from $srcFileHash->{PATH}...\n";
            }
        }

        # Process macros in local file
        if ( $PUTFILE_ATTS->{process} eq 'YES' ) {
            preProcessFile( $newfiledestination, $extraOps );
        }
    }
    else {
        print "HALT: $destHash->{HOST} has no associated IP address in $SECURERUN->{h}\n";
        exit;
    }
    return;
}

# copies a file on remote host 1 to remote host 2 - macro processing is done while
# on the local host

sub putRemote1ToRemote2 {

    # Original
    my $originalDir     = $PUTFILE_ATTS->{to};
    my $originalNewname = '';
    if ( $PUTFILE_ATTS->{as} eq '' ) {
        $originalNewname = getLastPathMember( $PUTFILE_ATTS->{src} );
    }
    else {
        $originalNewname = "$PUTFILE_ATTS->{as}";
    }

    # Tmp for remote to local
    my $tmpNewName = getTmpName();
    $PUTFILE_ATTS->{to} = $SECURERUN->{tmpdir};
    $PUTFILE_ATTS->{as} = $tmpNewName;

    # Get from remote host 1 and put on local using tmp name
    putRemoteToLocal();

    # Put local file on remote - restoring original or as..
    $PUTFILE_ATTS->{src} = "$PUTFILE_ATTS->{to}/$tmpNewName";
    $PUTFILE_ATTS->{to}  = "$originalDir";
    $PUTFILE_ATTS->{as}  = "$originalNewname";

    # Be sure to not process macros twice
    $PUTFILE_ATTS->{process} = 'NO';

    # Put onto remote 2 from local
    putLocalToRemote();

    # Remove local tmp dir
    unlink "$SECURERUN->{tmpdir}/$tmpNewName" or die $!;
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# <runfile>/<rfile> state support functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub runfileTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;
    if ( defined( $attributes->[0]{run} ) ) {
        if ( defined( $attributes->[0]{file} ) ) {
            chomp $attributes->[0]{file};
            $RUNFILE_ATTS->{file} = qq($attributes->[0]{file});

            #interp
            if ( defined( $attributes->[0]{interp} ) ) {
                chomp $attributes->[0]{interp};
                $RUNFILE_ATTS->{interp} = qq($attributes->[0]{interp});
            }
            else {
                $SYSMSG = "Warning: <runfile interp=\"\".../> not defined...\n";
                showIfVerbose( $SYSMSG, 2 );
                $RUNFILE_ATTS->{interp} = '';
            }

            #cmd - macros interpolated later
            if ( defined( $attributes->[0]{cmd} ) ) {
                $RUNFILE_ATTS->{cmd} = qq($attributes->[0]{cmd});
            }
            else {
                $RUNFILE_ATTS->{cmd} = '';
            }

            #args
            if ( defined( $attributes->[0]{args} ) ) {
                chomp $attributes->[0]{args};
                $RUNFILE_ATTS->{args} = qq($attributes->[0]{args});
            }
            else {
                $RUNFILE_ATTS->{args} = '';
            }

            #require
            $RUNFILE_ATTS->{require} = validateYesNo( $attributes->[0]{require}, 'YES' );

            #wait
            $RUNFILE_ATTS->{wait} = validateWait( $attributes->[0]{wait} );

            #preprocess
            $RUNFILE_ATTS->{process} = validateYesNo( $attributes->[0]{process}, 'YES' );

            # name of STDOUT to be saved in %extraOps - validate name
            if ( defined( $attributes->[0]{name} ) ) {
                if ( $attributes->[0]{name} =~ m/[a-zA-Z0-9.]*/ ) {
                    $RUNFILE_ATTS->{name} = $attributes->[0]{name};
                }
                else {
                    warn "WARNING: <script>/<runfile> detected with invalid \"name\" attribute...resetting to \"STDOUT\"\n";
                    $RUNFILE_ATTS->{name} = 'STDOUT';
                }
            }
            else {
                $RUNFILE_ATTS->{name} = 'STDOUT';
            }
            sleep $RUNFILE_ATTS->{wait};
        }
        else {
            print "HALT: <runfile file=\"\".../> not defined...\n";
            exit;
        }
    }
    else {
        $SYSMSG = "WARNING: <runfile> not run...\n";
        showIfVerbose( $SYSMSG, 2 );
    }
    showCallerInfo(caller);
    return;
}

sub runfileTagEnd () {

    # Run using $RUNFILE_ATTS set in onRunFileStart
    runFileManager();
    $RUNFILE_ATTS = ();
    showCallerInfo(caller);
    return;
}

sub runFileManager {
    if ( isLocal( $RUNFILE_ATTS->{file} ) eq 1 ) {
        $SYSMSG = "$RUNFILE_ATTS->{file} is local and valid...\n";
        showIfVerbose( $SYSMSG, 2 );
        runLocalFile();
    }
    elsif ( isRemote( $RUNFILE_ATTS->{file} ) eq 1 ) {
        $SYSMSG = "$RUNFILE_ATTS->{file} is remote and valid...\n";
        showIfVerbose( $SYSMSG, 2 );
        runRemoteFile();
    }
    else {
        print "HALT: $RUNFILE_ATTS->{file} is not a valid file...\n";
        exit;
    }
    showCallerInfo(caller);
    return;
}

sub runLocalFile {
    my $srcFileHash = parseDirPath( $RUNFILE_ATTS->{file} );

    # ensure local file exists, if not warn or die
    if ( isLocalFile( $srcFileHash->{PATH} ) eq 1 ) {

        # get abs dir and ensure abs path
        my $tmpdir = getParentPath( $srcFileHash->{PATH} );

        # check for just file name - add relative path current, "."
        if ( $tmpdir eq '' ) {
            $tmpdir = getcwd;
        }
        $tmpdir = Cwd::realpath($tmpdir);
        my $tmpfile = getLastPathMember( $srcFileHash->{PATH} );
        my $newfile = "$tmpdir/$tmpfile";
        if ( $RUNFILE_ATTS->{process} eq 'YES' ) {

            # copy file to tmp, reassign $newfile
            $newfile = sprintf qq{%s/%s}, $tmpdir, getTmpName();
            copy( "$tmpdir/$tmpfile", $newfile );

            # process file (sub ensures it is a text file)
            preProcessFile( $newfile, $extraOps );

            # assign new file to hash
            $srcFileHash->{PATH} = $newfile;

            # schedule $newfile for removal
            push @$filesToRemove, $srcFileHash->{PATH};
        }
        $srcFileHash->{PATH} = $newfile;

        # get interp info
        my $interpHash = getInterpInfo( $SECURERUN->{localhost}, $RUNFILE_ATTS->{interp} );

        # validate interpretor
        if ( isValidInterp( $RUNFILE_ATTS->{interp}, $RUNFILE_ATTS->{file} ) ne 1 ) {
            if ( $RUNFILE_ATTS->{require} eq 'YES' ) {
                print "HALT: Invalid interpretor, $RUNFILE_ATTS->{interp} detected in $RUNFILE_ATTS->{file}...\n";
                exit;
            }
            else {
                warn "WARNING: Invalid interpretor, $RUNFILE_ATTS->{interp} detected \nfor use on $RUNFILE_ATTS->{file}...\n";
            }
        }
        else {
            my $interp = "$interpHash->{BIN} $interpHash->{FLAGS}";
            my $file   = $srcFileHash->{PATH};

            # use default cmd string if tag attribute is not provided.
            if ( $RUNFILE_ATTS->{cmd} eq '' && defined( $interpHash->{DEFAULT_CMD} ) ) {
                $RUNFILE_ATTS->{cmd} = $interpHash->{DEFAULT_CMD};
            }
            my $cmd = createCmd( $interp, $file );
            if ( !-x $file && $interpHash->{BIN} eq '' ) {
                $SYSMSG = "WARNING: $file is not executable\n";
                showIfVerbose( $SYSMSG, 1 );
            }

            $SYSMSG = qx/$cmd/;
            my $exit_code = $? >> 8;
            if ( $exit_code != EXIT_SUCCESS ) {
                printf "HALT: local command exited non-zero code ($exit_code)\n$SYSMSG";
                exit $exit_code;
            }

            # capture STDOUT
            if ( $RUNFILE_ATTS->{name} ne 'STDOUT' ) {
                chomp $SYSMSG;
                addToExtraOps( $RUNFILE_ATTS->{name}, $SYSMSG );
                addToExtraOps( 'STDOUT',              $SYSMSG );

                # hided named STDOUTs until verbost level 2
                showIfVerbose( $SYSMSG, 2 );
            }
            else {

                # By default, and unnamed or badly named STDOUT is renamed to STDOUT,
                # so even though it uses a hash here, the value is "STDOUT".
                addToExtraOps( $RUNFILE_ATTS->{name}, $SYSMSG );

                # if not named STDOUT, send to screen at verbose level 1
                showIfVerbose( $SYSMSG, 1 );
            }
        }
    }
    elsif ( $RUNFILE_ATTS->{require} eq 'YES' ) {
        print "HALT: Local $srcFileHash->{PATH} file not found...\n";
        exit EXIT_ERROR;
    }
    elsif ( $RUNFILE_ATTS->{require} eq 'NO' ) {
        warn "WARN: Local $srcFileHash->{PATH} file not found...\n";
    }
    showCallerInfo(caller);
    return;
}

sub runRemoteFile {
    my $srcFileHash   = parseDirPath( $RUNFILE_ATTS->{file} );
    my $hostIPAddress = getIPAddress( $srcFileHash->{HOST} );

    # get host ip, verify
    if ( $hostIPAddress ne -1 ) {

        # get interp info
        my $interpHash = getInterpInfo( $SECURERUN->{localhost}, $RUNFILE_ATTS->{interp} );

        # validate interpretor
        if ( isValidInterp( $RUNFILE_ATTS->{interp}, $RUNFILE_ATTS->{file} ) ne 1 ) {
            if ( $RUNFILE_ATTS->{require} eq 'YES' ) {
                print "HALT: Invalid interpretor, $RUNFILE_ATTS->{interp} detected in $RUNFILE_ATTS->{file}...\n";
                exit;
            }
            else {
                warn "WARNING: Invalid interpretor, $RUNFILE_ATTS->{interp} detected \nfor use on $RUNFILE_ATTS->{file}...\n";
            }
        }
        else {
            my $interp = "$interpHash->{BIN} $interpHash->{FLAGS}";
            my $file   = $srcFileHash->{PATH};

            # use default cmd string if tag attribute is not provided.
            if ( $RUNFILE_ATTS->{cmd} eq '' && defined( $interpHash->{DEFAULT_CMD} ) ) {
                $RUNFILE_ATTS->{cmd} = $interpHash->{DEFAULT_CMD};
            }
            my $cmd = createCmd( $interp, $file );
            $SYSMSG = execViaSSH( $hostIPAddress, $srcFileHash->{USERNAME}, $srcFileHash->{PORT}, $cmd );
            chomp $SYSMSG;

            # capture STDOUT
            if ( $RUNFILE_ATTS->{name} ne 'STDOUT' ) {
                addToExtraOps( $RUNFILE_ATTS->{name}, $SYSMSG );
                addToExtraOps( 'STDOUT',              $SYSMSG );

                # hide named STDOUTs until verbost level 2
                showIfVerbose( $SYSMSG, 2 );
            }
            else {

                # By default, and unnamed or badly named STDOUT is renamed to STDOUT,
                # so even though it uses a hash here, the value is "STDOUT".
                addToExtraOps( $RUNFILE_ATTS->{name}, $SYSMSG );

                # if not named STDOUT, send to screen at verbose level 1
                showIfVerbose( $SYSMSG, 1 );
            }
        }
    }
    elsif ( $RUNFILE_ATTS->{require} eq 'YES' ) {
        print "HALT: $RUNFILE_ATTS->{file} doesn't contain a valid host...\n";
        exit;
    }
    elsif ( $RUNFILE_ATTS->{require} eq 'NO' ) {
        warn "WARN: $RUNFILE_ATTS->{file} doesn't contain a valid host...\n";
    }
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# <script> state support functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub scriptTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;
    $PARSER->{SCRIPT_FLAG} = 1;
    $SCRIPT_ATTS->{keep}   = validateYesNo( $attributes->[0]{keep}, 'NO' );
    if ( !defined( $attributes->[0]{file} ) ) {
        $attributes->[0]{file} = sprintf qq{%s/%s}, $SECURERUN->{tmpdir}, getTmpName();
    }
    if ( !defined( $attributes->[0]{run} ) ) {
        $attributes->[0]{run} = 'YES';
    }
    if ( !defined( $attributes->[0]{file} ) ) {
        $attributes->[0]{file} = sprintf qq{%s/%s}, $SECURERUN->{tmpdir}, getTmpName();
    }

    # Set default element in %extraOps of the standard output to be STDOUT
    if ( !defined( $attributes->[0]{name} ) ) {
        $attributes->[0]{name} = "STDOUT";
    }

    # the rest is exactly in line with the <runfile> tag :)
    runfileTagStart(@attributes);
    showCallerInfo(caller);
    return;
}

# create file, send to remote location if necessary

sub scriptTagCode {
    my ($commentText) = $_[0];
    if ( $PARSER->{SCRIPT_FLAG} eq 1 ) {
        my $srcFileHash = parseDirPath( $RUNFILE_ATTS->{file} );
        my $isLocal     = isLocal( $RUNFILE_ATTS->{file} );
        my $filename    = getLastPathMember( $srcFileHash->{PATH} );
        my $dir         = getParentPath( $srcFileHash->{PATH} );
        my $outfile     = '';
        if ( $isLocal eq 1 ) {
            ensureLocalDir( $dir, 0755 );
            $outfile = "$srcFileHash->{PATH}";
            if ( $RUNFILE_ATTS->{process} eq 'YES' ) {
                $commentText = preProcessStr( $commentText, $extraOps );
                $RUNFILE_ATTS->{process} = 'NO';
            }
            writeScriptFile( $commentText, $outfile );
            $RUNFILE_ATTS->{file} = $outfile;
        }
        elsif ( $isLocal eq 0 ) {
            if ( $RUNFILE_ATTS->{process} eq 'YES' ) {
                $commentText = preProcessStr( $commentText, $extraOps );
                $RUNFILE_ATTS->{process} = 'NO';
            }
            my $tmpname = getTmpName();
            $outfile = sprintf qq{%s/%s}, $SECURERUN->{tmpdir}, $tmpname;
            writeScriptFile( $commentText, $outfile );
            $PUTFILE_ATTS->{to}      = "$srcFileHash->{USERNAME}\@$srcFileHash->{HOST}#$srcFileHash->{PORT}:$dir";
            $PUTFILE_ATTS->{src}     = $outfile;
            $PUTFILE_ATTS->{require} = $RUNFILE_ATTS->{require};
            $PUTFILE_ATTS->{process} = $RUNFILE_ATTS->{process};
            $PUTFILE_ATTS->{as}      = $filename;
            $PUTFILE_ATTS->{keep}    = "NO";

            # send file
            putLocalToRemote();

            # reset hash
            $PUTFILE_ATTS = ();
        }
        else {
            print "HALT: $RUNFILE_ATTS->{file} is not a valid destination...\n";
            exit;
        }

        # schedule for removal :)
        if ( $SCRIPT_ATTS->{keep} eq 'NO' ) {
            push @$filesToRemove, $outfile;
        }
    }
    showCallerInfo(caller);
    return;
}

#
#  Writes out script file in <script>
#

sub writeScriptFile {
    my ( $scriptText, $targetFile ) = @_;
    open my $TMPFILE, '>', "$targetFile";
    for my $text ( split( '\n', $scriptText ) ) {

        #covert tabs to spaces
        $text =~ s/^\t/       /g;

        #shift all text over 6 spaces to the left
        $text =~ s/^\s{1,6}//g;

        # Write line if not blank or a CDATA line
        if ( $text !~ m/^$/ && $text !~ m/<!\[CDATA\[/ && $text !~ m/\]\]>/ ) {
            print $TMPFILE "$text\n";
        }
    }
    close $TMPFILE;
    showCallerInfo(caller);
    return;
}

sub scriptTagEnd {
    runfileTagEnd();
    $PARSER->{SCRIPT_FLAG} = 0;
    $SCRIPT_ATTS = ();
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  <define/> state support functions
#    -- STDOUT can be saved to a macro via the <script> and <runfile> tags
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub defineTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;
    if ( defined( $attributes->[0]{name} ) ) {
        if ( $attributes->[0]{name} =~ m/[a-zA-Z0-9.]*/ ) {
            if ( defined( $attributes->[0]{value} ) ) {
                addToExtraOps( qq($attributes->[0]{name}), qq($attributes->[0]{value}) );
            }
            else {
                warn "WARNING: <define/> detected with \"value\" attribute - variable set to NULL string\n";
                addToExtraOps( qq($attributes->[0]{name}), '' );
            }
        }
        else {
            warn "WARNING: <define/> detected with invalid \"name\" attribute\n";
        }
    }
    else {
        warn "WARNING: <define/> detected with no \"name\" attribute\n";
    }
    showCallerInfo(caller);
    return;
}

sub defineTagEnd {
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  <undefine/> state support functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub undefineTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;
    if ( defined( $attributes->[0]{name} ) ) {
        if ( $attributes->[0]{name} =~ m/[a-zA-Z0-9.]*/ ) {
            removeFromExtraOps(qq($attributes->[0]{name}));
        }
        else {
            warn "WARNING: <undefine/> detected with invalid \"name\" attribute\n";
        }
    }
    else {
        warn "WARNING: <undefine/> detected with no \"name\" attribute\n";
    }
    showCallerInfo(caller);
    return;
}

sub undefineTagEnd {
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  <chbasedir/> state support functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub chbasedirTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;
    if ( $attributes->[0]{to} ) {
        my $to = preProcessStr( $attributes->[0]{to}, $extraOps );

        # if relative path, it is relative to current basedir
        ensureLocalDir( $to, 0755 );
        $SECURERUN->{BASEDIR} = Cwd::realpath($to);
        addToExtraOps( 'BASEDIR', $SECURERUN->{BASEDIR} );
        cdCwdToBASEDIR();
        showIfVerbose( $SYSMSG, 1 );
        return;
    }
    print "HALT: dir attribute for <chbasedir/> not specified\n";
    exit EXIT_ERROR;
}

sub chbasedirTagEnd {
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  <input/> state support functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub inputTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;
    my $default      = '';
    if ( not $SECURERUN->noinputtag ) {
        if ( exists( $attributes->[0]{name} ) ) {
            if ( exists( $attributes->[0]{msg} ) ) {
                my $showDefault = '>';
                if ( exists( $attributes->[0]{default} ) ) {
                    $default     = $attributes->[0]{default};
                    $showDefault = "\n($default) >";
                }

                # shift lines over for multi-lined text
                $attributes->[0]{msg} =~ s/\n\s*/\n/g;
                print "\n" . qq($attributes->[0]{msg}) . " $showDefault";
                my $in = <TTY>;
                chomp $in;
                if ( $in !~ m/^$/ ) {
                    $in = preProcessStr( $in, $extraOps );
                    addToExtraOps( qq($attributes->[0]{name}), $in );
                    $SYSMSG = "WARN: Macro read in via <input/> tag ...\n";
                    showIfVerbose( $SYSMSG, 2 );
                }
                else {
                    if ( $default !~ m/^$/ ) {
                        addToExtraOps( qq($attributes->[0]{name}), $default );
                    }
                    else {
                        $SYSMSG = "WARN: Blank STDIN detected from <input/>.  Use <define/> or <undefine/> to reset a macro..\n";
                        showIfVerbose( $SYSMSG, 2 );
                    }
                }
            }
            else {
                $SYSMSG = "WARN: name attribute not included in <input/> tag..\n";
                showIfVerbose( $SYSMSG, 1 );
            }
        }
        else {
            $SYSMSG = "WARN: name attribute not included in <input/> tag..\n";
            showIfVerbose( $SYSMSG, 1 );
        }
    }
    showCallerInfo(caller);
    return;
}

sub inputTagEnd {
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  <output/> state support functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub outputTagStart {
    my (@attributes) = $_[0];
    my ($attributes) = \@attributes;
    if ( exists( $attributes->[0]{msg} ) ) {
        chomp $attributes->[0]{msg};

        # shifts text left for multi line entries
        $attributes->[0]{msg} =~ s/\n\s*/\n/g;
        print "\n" . qq($attributes->[0]{msg}) . "\n";
    }
    showCallerInfo(caller);
    return;
}

sub outputTagEnd {
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# HTML::Parser event handlers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# This event is triggered when a processing instructions markup is
# recognized. The format and content of processing instructions is system
# and application dependent such as <? XML ...> or <? HTML ...>.
sub onProcess {
    showCallerInfo(caller);
    return;
}

# Invoked when a start tag is encountered
sub onStart {
    my ( $tagName, @attributes ) = @_;

    # Interactive mode
    if ( $SECURERUN->{i} ) {
        print "START..<$tagName>: press key to continue [ctrl-c to quit]";
        my $ans = <STDIN>;
    }

    # create reference to array of hashes
    my $attributes = \@attributes;

    # cycle through attributes values only - very inefficient
    foreach my $valpair ( keys( %{ $attributes->[0] } ) ) {
        $attributes->[0]{$valpair} = preProcessStr( $attributes->[0]{$valpair}, $extraOps );
    }
    my $TagStartSub = $tagName . "TagStart(\@attributes)";
    eval $TagStartSub;
    showCallerInfo(caller);
    return;
}

# Invoked for text between tags - implement some validation here
sub onText {
    ;
    my ($text) = $_[0];
    if ( $PARSER->{SCRIPT_FLAG} eq 1 ) {
        $text = preProcessStr( $text, $extraOps );
        scriptTagCode($text);
    }
    if ( $SECURERUN->showtext ) {
        if ( $text =~ m/[\w\d]/ && $text !~ m/^[\s\n]*$/ ) {
            chomp $text;
            print "$text\n";
        }
    }
    showCallerInfo(caller);
    return;
}

# Invoked when comments are encountered - print if flagged to do so
sub onComment {
    my ($commentText) = @_;
    if ( $SECURERUN->showcomments ) {
        my $processedComment = preProcessStr( $commentText, $extraOps );
        my @lines            = split /\n/, $processedComment;
        my @to_print         = ();
        foreach my $l (@lines) {
            $l =~ s/^ +<!--/<!--/;
            $l =~ s/^ +-->/-->/;
            if ( $l !~ m/^<!--|-->/ ) {
                $l = qq{  $l};    # shift over to the right 2 spaces for better reading with --showcomments
            }
            push @to_print, $l;
        }
        push @to_print, q{};
        print join( qq{\n}, @to_print );
    }
    showCallerInfo(caller);
    return;
}

# Invoked when an ending tag is encountered
sub onEnd {
    my ($tagName) = @_;

    # Interactive mode
    if ( $SECURERUN->i ) {
        print "END....<$tagName>: press key to continue [ctrl-c to quit]";
        my $ans = <STDIN>;
    }
    my $TagEndSub = $tagName . "TagEnd()";
    eval $TagEndSub;

    # purge @filesToRemove array if it is larger than 10 files
    if ( @$filesToRemove > 10 ) {
        unlink @$filesToRemove;
    }
    showCallerInfo(caller);
    return;
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Driver of securerun functionality
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

sub main {

    # Builds string of Mark Up Language (ML) data; accepts file or stream of data
    my $ML = '';
    if ( defined( $SECURERUN->{f} ) ) {
        $ML = txtFileToString( $SECURERUN->{f} );
    }
    else {
        while (<STDIN>) {
            $ML .= $_;
        }
    }

    # 1) Preprocess $ML with %extraOps - these are static vars
    #    invoked through command line "-o" and envronmental vars.
    #    run file processed by default unlees "-dontprocessrunfile" is set
    if ( $SECURERUN->dontprocesrunfile ) {
        $ML = preProcessStr( $ML, $extraOps );
    }

    # 2) Feed $ML data to $PARSER to parse and invoke
    #    event driven actions (see handlers)
    $PARSER->parse($ML);

    # !!CHANGE TO "-saverunfile"!!!
    # 3) Dump out copy of the run file in basedir if "-saverunfile" is set
    if ( $SECURERUN->saverunfile ) {
        open my $RUNFILE, q{>}, $SECURERUN->saverunfile;
        print $RUNFILE $ML;
        close $RUNFILE;
    }
    showCallerInfo(caller);
    return;
}

# Call sub init
init();

# Call sub main
main();

# Flush parser buffer
$PARSER->eof;

exit;

# END block - always run last
END {
    unlink @$filesToRemove;
    rmtree $SECURERUN->{tmpdir};
}

__END__

# $Revision: 1.136 $ $Date: 2004/03/11 23:47:59 $ $Author: estrade $
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Project information
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  OPTIONS
#   -c
#        clear screen when securerun is activated
#
#   -f
#        supports old style securerun runfile option
#
#   -h
#        specifies the ~/securerun.conf file that describes the environment
#        of the machine you are working from.  If not specified, it searches
#        all the directories listed in your PATH enviromental variable.  It
#        is best to place this in your home directory and make sure that "~"
#        is in your path.
#
#   -i   interactive mode - asks for user to hit a key whenever a start tag
#        is encountered - useful for debugging.
#
#
#   -l
#        allows user to select any host in ~/securerun.conf as their local host;
#        default is "localhost," and it is specified using the value of the
#        "name" attribute in the "host" tag.
#
#   -o
#        specify arguments to pass through to the configuration file for
#        preprocessing; ex -o ARG1=123 -o ARG2=abc will result in $ARG1 and
#        $ARG2 in the configuration being replaced with 123 and abc
#        respectively prior to the actual running of the config file
#
#   -v
#        verbose mode
#
#   -checkmacro [none|warn|halt]
#        sets the level and response of unresolved
#        macros (ex, %VARNAME%); options are none, warn, and halt;
#        default is none.  !THIS OPTION IS NOT FULLY IMPLEMENTED!
#
#   -saverunfile
#        if set, a copy of the actual run file is dumped in the base
#        directory.
#
#   -dontprocessrunfile
#        if set, securerun will not process the run file; the run file
#        is processed for macros by default.
#
#   -noenv
#        doesn't read in environment into %extraOps hash used in macro
#        processing
#
#   -noinput
#        disables <input> tag used for interactivity - could break scripts
#        that depend on user input, but could be useful if run in batch
#        defining vars through "-o"
#
#   -nosplash
#        do not display securerun splash message
#
#   -showcomments
#        displays comments during processing - useful for status messages
#
#   -showtext
#        displays all text detected by HTML::Parser
#
#   -version
#        lists the version number and exits
#
#   DEPENDANCIES
#    Perl 5.6.0+ (+ core modules GetOpts, File), HTML::Parser, ssh, scp
#
#    HTML::Parser documentation is at:
#    http://www.perldoc.com/perl5.6.1/lib/HTML/Parser.html
#    If it is not installed system wide, install locally, and
#    utilize environmental variable, PERL5LIB (colon delimited) to point
#    to the location of the lib.
#
#   PLATFORMS
#    Any thing with Perl 5.6.1 on it ;)
#
#   TERMS
#    Nothing in whole or part can be reproduced until further notice, and
#    I am not responsible for any damage done to any systems from the use
#    of this code.
#
#   AUTHOR(S)
#    Original conception and development:
#    Brett D. Estrade <estrade@nrlssc.navy.mil>
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

